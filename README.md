# Встановлення репозиторію

1. Склонуйте репозиторій

```bash
git clone [repository-url]
cd goit-algo-hw-04
```

2. Перейдіть у директорію проєкту та активуйте віртуальне середовище

```bash
 python -m venv .venv
 # On Windows:
 .venv\Scripts\activate
 # On Unix/MacOS:
 source .venv/bin/activate
```

3. Встановіть необхідні залежності

```bash
pip install -r requirements.txt
```

4. Перейдіть в папку з відповідним завданням

```bash
cd task_1
```

1. Запустіть головний файл main.py

```bash
python -m main
```

# Завдання 1: Метод delete для таблиці HashTable

Додайте метод `delete` для видалення пар ключ-значення таблиці `HashTable`, яка реалізована в конспекті.

# Завдання 2: Метод delete для таблиці HashTable

Реалізуйте двійковий пошук для відсортованого масиву з дробовими числами. Написана функція для двійкового пошуку повинна повертати кортеж, де першим елементом є кількість ітерацій, потрібних для знаходження елемента. Другим елементом має бути "верхня межа" — це найменший елемент, який є більшим або рівним заданому значенню.

# Завдання 3: Порівняння ефективності алгоритмів пошуку підрядка на основі текстових файлів

Ця задача порівнює продуктивність наступних трьох алгоритмів пошуку рядка в Python:

- Алгоритм Кнута-Морріса-Пратта (KMP)
- Алгоритм Боєра-Мура (BM)
- Алгоритм Рабіна-Карпа (RK)

На основі отриманих даних визначали найшвидший алгоритм для кожного тексту окремо та в цілому.

## Налаштування тестування

- Використовували два текстових файли (Стаття 1 та Стаття 2).
- Для кожного тексту перевіряли пошук трьох типів паттернів: короткий, середній та довгий.
- Для кожного тексту перевіряли пошук реальних (існуючі в тексті) і вигаданих (відсутні паттернів).
- Час виконання вимірювався за допомогою модуля timeit.

## Аналіз та висновки

### Залежність від тексту

**Стаття 1**: Найшвидшим алгоритмом стабільно виявився BM, час виконання якого був в десятки разів менший за KMP і RK. KMP був помірно швидким, а RK — найповільніший.
**Cтаття 2**: Схожа тенденція: BM показав найкращі результати, KMP — середні, RK — найповільніший. В цілому, алгоритми працюють трохи швидше через менший розмір тексту та меншу складність рядків.

**Висновок**: швидкість алгоритмів залежить від довжини та структури тексту, але BM стабільно лідирує.

### Залежність від розміру паттерна

**Короткі паттерни**: BM значно швидший, KMP — середній, RK — повільний.

**Середні та довгі паттерни**: BM все ще лідирує, хоча для дуже довгих паттернів різниця між BM і KMP зменшується. RK залишається найповільнішим.

**Висновок**: збільшення довжини паттерна незначно впливає на відносну ефективність BM і KMP, але істотно погіршує продуктивність RK.

### Залежність від наявності паттерна

**Реальні паттерни**: всі алгоритми виконують пошук швидше, особливо BM, оскільки алгоритм може здійснити великі стрибки при невідповідностях.

**Вигадані паттерни**: час виконання KMP та RK трохи збільшується, BM залишається дуже швидким, оскільки його стратегія "стрибків" дозволяє швидко виявляти відсутність паттерна.

**Висновок**: BM найбільш ефективний як для наявних, так і для відсутніх паттернів. KMP демонструє стабільний час пошуку незалежно від наявності, RK повільний у всіх випадках.

### Загальні висновки

Найшвидшим та найбільш стабільним для обох текстів і для всіх розмірів паттернів виявився алгоритм Бойєра-Мура. Алгоритм Кнута-Морріса-Пратта показав трохи помірніші, але все ще добрі результати. При цьому час виконання є доволі стабільним незалежно від довжини підрядка, який шукається в тексті, а при пошуку великих рядків його ефективність починає зрівнюватись з ефективністю алгоритма Бойєра-Мура. Найповільнішим, особливо для великих текстів та довгих паттернів, виявився алгоритм Рабіна-Карпа, однак слід зазначити, що його ефективність багато в чому визначається функцією хешування. При виконанні данного завдання використовувалась реалізація алгоритму, наведена в навчальному конспекті, однак за умови підбору більш специфічної для задачі хеш функції ефективність даного алгоритму може значно зрости.

Отже, для реальних текстових пошуків найбльш доцільним буде використовувати алгоритм Бойєра-Мура. KMP може підійти для забезпечення стабільного часу пошуку незалежно від розміру паттерна, а RK варто застосовувати тільки для спеціальних випадків (наприклад, множинний пошук) і за умови чіткого розуміння, які саме особливості даних має враховувати функція хешування.
